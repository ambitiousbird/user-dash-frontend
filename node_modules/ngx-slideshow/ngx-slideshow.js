import { CommonModule } from '@angular/common';
import { Component, HostListener, Input, NgModule, Renderer2, ViewChild } from '@angular/core';

class NgxSlideshowComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this.cards = 1;
        this.padding = '14px';
        this.cardSize = '100%';
        this.disableTabbing = false; // If true, you cannot tab to other slides
        this.resizeViewport = true;
        this.unit = 'px';
        // Set initial index
        this.index = 0;
        this.min = -1;
        this.findNumbers = new RegExp(/([0-9]+(?:[.][0-9]+)?)(?![\.\w])/g);
        this.findPercentages = new RegExp(/([0-9]+(?:[.][0-9]+)?%)/g);
        // To use with HammerJS
        this.SWIPE_ACTION = { LEFT: 'swipeleft', RIGHT: 'swiperight' };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.onResize();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.onResize();
    }
    /**
     * @return {?}
     */
    right() {
        this.rightBy(1);
    }
    /**
     * @return {?}
     */
    left() {
        this.leftBy(1);
    }
    /**
     * @param {?} i
     * @return {?}
     */
    goTo(i) {
        if (i > this.max || i < this.min) {
            throw new Error('goTo number on slideshow is out of bounds');
        }
        else {
            this.index = i;
            this.setLeft();
        }
    }
    /**
     * @param {?} i
     * @return {?}
     */
    leftBy(i) {
        this.index = this.calc(this.index - i);
        this.setLeft();
    }
    /**
     * @param {?} i
     * @return {?}
     */
    rightBy(i) {
        this.index = this.calc(this.index + i);
        this.setLeft();
    }
    /**
     * @param {?} newIndex
     * @return {?}
     */
    calc(newIndex) {
        if (this.max <= newIndex) {
            return this.calc(newIndex - this.max);
        }
        else if (this.min >= newIndex) {
            return this.calc(this.max + newIndex);
        }
        else {
            return newIndex;
        }
    }
    /**
     * @return {?}
     */
    setLeft() {
        const /** @type {?} */ newSize = `calc(0px - calc(calc(${this.trueCardSize} + ${this.truePaddingSize}) * ${this.index}))`;
        this.renderer.setStyle(this.slides.nativeElement, 'left', newSize);
        if (this.disableTabbing) {
            // This will disallow tabbing to other slides
            this.toggleCardListInput();
        }
    }
    /**
     * @param {?=} action
     * @return {?}
     */
    swipe(action = this.SWIPE_ACTION.RIGHT) {
        if (action === this.SWIPE_ACTION.RIGHT) {
            this.left();
        }
        if (action === this.SWIPE_ACTION.LEFT) {
            this.right();
        }
    }
    /**
     * @param {?} card
     * @param {?} num
     * @return {?}
     */
    toggleCardInput(card, num) {
        for (const /** @type {?} */ input of card.querySelectorAll('button, input')) {
            input.tabIndex = num;
        }
    }
    /**
     * @return {?}
     */
    toggleCardListInput() {
        const /** @type {?} */ cardObjs = this.slides.nativeElement.querySelectorAll('li');
        const /** @type {?} */ numCards = cardObjs.length;
        for (let /** @type {?} */ i = 0; i < numCards; i++) {
            if ((i < this.index) || (i >= (this.index + this.cards))) {
                this.toggleCardInput(cardObjs[i], -1); // Disable tabs
            }
            else {
                this.toggleCardInput(cardObjs[i], 0); // Enable tabs
            }
        }
    }
    /**
     * @param {?} percentage
     * @return {?}
     */
    convertPercentageToNumber(percentage) {
        const /** @type {?} */ num = Number(percentage.slice(0, -1)) / 100;
        return `${this.viewSize * num}px`;
    }
    ;
    /**
     * @param {?} unitless
     * @return {?}
     */
    convertNumberToUnit(unitless) {
        return `${unitless}${this.unit}`;
    }
    /**
     * @return {?}
     */
    onResize() {
        const /** @type {?} */ cardObjs = this.slides.nativeElement.getElementsByTagName('li'); // Get list of objects
        const /** @type {?} */ numCards = cardObjs.length; // Find out how many cards there are
        this.max = (numCards - this.cards) + 1; // Calculate max: # cards you see on screen - full # of cards
        if (!this.resizeViewport) {
            this.renderer.removeStyle(this.viewport.nativeElement, 'width');
            // This is being done because [class.full-width] was not working in tests
            this.renderer.addClass(this.viewport.nativeElement, 'full-width');
            this.viewSize = this.viewport.nativeElement.offsetWidth;
        }
        // Gets card size based on viewport (to calculate % based sizes)
        if (this.cardSize.includes('%') && this.resizeViewport) {
            this.renderer.setStyle(this.viewport.nativeElement, 'width', this.cardSize);
            this.trueCardSize = `${this.viewport.nativeElement.offsetWidth}px`;
        }
        else if (this.cardSize.includes('%') && !this.resizeViewport) {
            // TODO: Add tests for all unit types such as this
            this.trueCardSize = this.cardSize
                .replace(this.findPercentages, this.convertPercentageToNumber.bind(this)) // Turn into decimal to do math
                .replace(this.findNumbers, this.convertNumberToUnit.bind(this));
        }
        else {
            this.trueCardSize = this.cardSize.replace(this.findNumbers, this.convertNumberToUnit.bind(this));
        }
        // Gets card size based on viewport (to calculate % based sizes)
        if (this.padding.includes('%') && this.resizeViewport) {
            this.renderer.setStyle(this.viewport.nativeElement, 'width', this.padding);
            this.truePaddingSize = `${this.viewport.nativeElement.offsetWidth}px`;
        }
        else if (this.padding.includes('%') && !this.resizeViewport) {
            this.truePaddingSize = this.padding
                .replace(this.findPercentages, this.convertPercentageToNumber.bind(this)) // Turn into decimal to do math
                .replace(this.findNumbers, this.convertNumberToUnit.bind(this));
        }
        else {
            this.truePaddingSize = this.padding.replace(this.findNumbers, this.convertNumberToUnit.bind(this));
        }
        // Set size of cards + padding for calculating slides div and viewport div
        const /** @type {?} */ fullCardSize = `calc(${this.trueCardSize} + ${this.truePaddingSize})`;
        // This is how wide the viewport will be
        if (this.resizeViewport) {
            this.renderer.setStyle(this.viewport.nativeElement, 'width', `calc(${fullCardSize} * ${this.cards})`);
        }
        // Set size of cards. Wish this could be class based, but alas not
        for (let /** @type {?} */ i = 0; i < numCards; i++) {
            this.renderer.setStyle(cardObjs[i], 'width', `${this.trueCardSize}`);
            this.renderer.setStyle(cardObjs[i], 'margin', `0 calc(${this.truePaddingSize} / 2)`);
        }
        this.setLeft();
    }
}
NgxSlideshowComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-slideshow',
                template: `
    <div #viewport id="viewport" class="ngx-slideshow-component viewport">
      <ul #slides id="slides" class="slides" style="left: 0;">
        <ng-content select="li"></ng-content>
      </ul>
    </div>
  `,
                styles: [`
    .ngx-slideshow-component.viewport{display:inline-block;overflow:hidden}.ngx-slideshow-component.viewport.full-width{width:100%}.ngx-slideshow-component.viewport .slides{-webkit-transition:all 1s ease;transition:all 1s ease;position:relative;white-space:nowrap;padding:0;margin:0;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;-webkit-box-sizing:border-box;box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.ngx-slideshow-component.viewport ::ng-deep .slides>li{position:relative;float:left;list-style:none}
  `]
            },] },
];
/**
 * @nocollapse
 */
NgxSlideshowComponent.ctorParameters = () => [
    { type: Renderer2, },
];
NgxSlideshowComponent.propDecorators = {
    'cards': [{ type: Input },],
    'padding': [{ type: Input },],
    'cardSize': [{ type: Input },],
    'disableTabbing': [{ type: Input },],
    'resizeViewport': [{ type: Input },],
    'unit': [{ type: Input },],
    'viewport': [{ type: ViewChild, args: ['viewport',] },],
    'slides': [{ type: ViewChild, args: ['slides',] },],
    'onResize': [{ type: HostListener, args: ['window:resize', [],] },],
};

class NgxSlideshowModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxSlideshowModule,
            providers: []
        };
    }
}
NgxSlideshowModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [NgxSlideshowComponent],
                declarations: [NgxSlideshowComponent]
            },] },
];
/**
 * @nocollapse
 */
NgxSlideshowModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { NgxSlideshowComponent, NgxSlideshowModule };
//# sourceMappingURL=ngx-slideshow.js.map
